--- eval.c.orig	2021-12-06 12:26:19.960220784 -0500
+++ eval.c	2021-12-06 12:36:24.797409216 -0500
@@ -51,6 +51,12 @@
 static void send_pwd_to_eterm PARAMS((void));
 static sighandler alrm_catcher PARAMS((int));
 
+long int currentTimeMillis() {
+  struct timeval time;
+  gettimeofday(&time, NULL);
+  return time.tv_sec * 1000 + time.tv_usec / 1000;
+}
+
 /* Read and execute commands until EOF is reached.  This assumes that
    the input source has already been initialized. */
 int
@@ -63,6 +69,7 @@
 
   current_command = (COMMAND *)NULL;
 
+
   our_indirection_level = ++indirection_level;
 
   if (just_one_command)
@@ -104,7 +111,7 @@
 		 leave existing non-zero values (e.g., > 128 on signal)
 		 alone. */
 	      if (last_command_exit_value == 0)
-		set_exit_status (EXECUTION_FAILURE);
+      		set_exit_status (EXECUTION_FAILURE);
 	      if (subshell_environment)
 		{
 		  current_command = (COMMAND *)NULL;
@@ -114,6 +121,7 @@
 	      /* Obstack free command elements, etc. */
 	      if (current_command)
 		{
+
 		  dispose_command (current_command);
 		  current_command = (COMMAND *)NULL;
 		}
@@ -162,13 +170,31 @@
 		  free (ps0_string);
 		}
 
-	      current_command_number++;
+	  current_command_number++;
+    long long started_ts = currentTimeMillis();
+    fprintf(stderr, 
+            ""
+            "<%d> [%d] (%lld) CMD-START>"
+            "\n\tCommand: %s\n",
+            getpid(), current_command_number, started_ts,
+            make_command_string (current_command)
+    );
+
 
 	      executing = 1;
 	      stdin_redir = 0;
 
 	      execute_command (current_command);
 
+    long long ended_ts = currentTimeMillis();
+    fprintf(stderr, 
+            "\tExited: %d"
+            "\n\tDuration: %lldms"
+            "\n",
+            last_command_exit_value,
+            (ended_ts-started_ts)
+    );
+
 	    exec_done:
 	      QUIT;
 
